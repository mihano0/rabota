ЗАДАЧА: Генерация всех перестановок строки.
Необходимо написать функцию, которая генерирует все возможные перестановки заданной строки.


Объяснение алгоритма (C++):
      1. Функция permute принимает строку и индексы левой и правой границы.
      2. Если левая граница равна правой, значит, достигнута одна из перестановок.
      3. В цикле происходит обмен символов и рекурсивный вызов.
      4. После рекурсивного вызова символы возвращаются на исходные позиции.

Объяснение алгоритма (Java):
      1. Функция permute принимает строку и индексы левой и правой границы.
      2. При достижении базового случая (левая граница равна правой) выводится перестановка.
      3. В цикле происходит обмен символов и рекурсивный вызов.
      4. Метод swap меняет символы в строке.
      
Объяснение алгоритма (Phyton):
      1. Функция permute принимает список символов и индексы левой и правой границы.
      2. При достижении базового случая выводится перестановка.
      3. В цикле происходит обмен символов и рекурсивный вызов.
      4. После рекурсивного вызова символы возвращаются на исходные позиции.


АНАЛИЗ ВРЕМЕННОЙ СЛОЖНОСТИ:
Временная сложность: O(n!), где n — длина строки.
Объяснение:
      Для строки длиной n существует n! перестановок.
      На каждом уровне рекурсии происходит n обменов символов.
      Таким образом, общее количество операций пропорционально n!.




КОНТРОЛЬНЫЙ ВОПРОС (10 вопрос: "Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?")

DFS (Depth-First Search) — алгоритм поиска в глубину, который исследует граф, погружаясь как можно глубже в каждую ветвь, прежде чем возвращаться назад.
      ИСПОЛЬЗУЙТЕ DFS, когда:
      1. Нужно найти любой путь между вершинами
      2. Требуется топологическая сортировка
      3. Решаете задачи с backtracking
      4. Память ограничена (для узких и глубоких графов)
      
BFS (Breadth-First Search) — алгоритм поиска в ширину, который исследует граф послойно, сначала посещая все вершины на расстоянии 1, затем на расстоянии 2 и так далее.
      ИСПОЛЬЗУЙТЕ BFS, когда:
      1. Нужно найти кратчайший путь (в невзвешенном графе)
      2. Требуется обход по уровням
      3. Ищете ближайший элемент к стартовой позиции
      4. Граф широкий и не очень глубокий
      


ПРИНЦИП РАБОТЫ:
DFS работает по принципу погружения в глубину:
      1. Начинает с начальной вершины
      2. Ищет максимально глубоко в каждую ветвь
      3. При достижении конца ветви возвращается назад
      4. Переходит к следующей непосещённой ветви


BFS работает по принципу обхода уровней:
      1. Начинает с начальной вершины
      2. Посещает все вершины на расстоянии 1
      3. Затем все вершины на расстоянии 2
      4. И так далее

ЗАКЛЮЧЕНИЕ
Выбор между DFS и BFS зависит от конкретной задачи и структуры данных. 
DFS лучше подходит для поиска путей и работы с глубокими структурами, тогда как BFS оптимален для поиска кратчайших путей и обхода по уровням.




